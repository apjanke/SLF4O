\input texinfo    @c -*-texinfo-*-

@c %**start of header

@set VERSION 0.1.0-SNAPSHOT

@setfilename slf40.info
@settitle SLF4O v@value{VERSION}
@documentencoding UTF-8

@c %**end of header

@copying
This manual is for SLF4O, version @value{VERSION}.

Copyright @copyright{} 2020 Andrew Janke

@quotation
Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the same conditions as for modified versions.
@end quotation
@end copying

@documentdescription
User manual for SLF4O for Octave.
@end documentdescription

@titlepage
@title  SLF4O
@subtitle version @value{VERSION}, April 2020
@author Andrew Janke
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@shortcontents
@contents


@ifnottex
@node Top, Setup
@top SLF4O

This manual is for SLF4O, version @value{VERSION}.
@end ifnottex

@menu
* Setup::
* API::
* The dispstr API::
* Configuration::
* Implementation notes::
* API Reference::
* Copying::
@end menu

@node Setup
@chapter Setup

To use SLF4O in your code:

1. Install and load the SLF4O package using Octave's @code{pkg} command

@code{pkg install https://github.com/apjanke/octave-slf4o/archive/master.zip}

2. Load the SLF4O package in your Octave session

@code{pkg load slf4o}

3. Call @code{logger.initSLF4O} to initialize the library before doing any logging calls

4. Add calls to the @code{logger.*} functions in your code

@node API
@chapter API

SLF4O provides:

@itemize
@item A set of logging functions to log events at various levels. This includes Regular and "@code{j}" variants for sprintf-style or SLF4J-style formatting.
@item A Logger class for doing logging with more control over its behavior.
@item A Log4j configurator tool and GUI.
@item @code{dispstr}, a customizable string-conversion API.
@end itemize

All the code is in the @code{+logger} package. I chose a short, readable package name because if you're using logging, it'll show up a lot in your code.

@node Logging functions
@section Logging functions

Each logging level has a corresponding @code{logger.*} function and "J Variant" function that you can call to emit a log message at that level.

@multitable @columnfractions .33 .33 .33
@headitem Level @tab Function @tab J Variant
@item @code{ERROR}
@tab @code{logger.error}
@tab @code{logger.errorj}
@item @code{WARNING}
@tab @code{logger.warn}
@tab @code{logger.warnj}
@item @code{INFO}
@tab @code{logger.info}
@tab @code{logger.infoj}
@item @code{DEBUG}
@tab @code{logger.debug}
@tab @code{logger.debugj}
@item @code{TRACE}
@tab @code{logger.trace}
@tab @code{logger.tracej}
@end multitable

The logging levels are predefined. They cannot be customized. This is a design decision made to keep the API simple and performant.

@node Calling logging functions
@subsection Calling logging functions

In your code, put calls to @code{logger.info(...)}, @code{logger.debug(...)}, and so on, as appropriate.

@example
    ...
    logger.info('Working on item %d of %d: %s', i, n, description);
    logger.debug('Intermediate value: %f', someDoubleValue);
    ...
@end example

@node Regular and j variants
@subsection Regular and j variants

The regular ("m") versions of the logging functions take @code{fprintf}-style formatting and arguments, with @code{%s}/@code{%f}/@code{%d}/etc placeholders. These calls look like normal Octave @code{fprintf()} calls. The argument conversion and formatting is done at the Octave level before the message is passed along to the SLF4J Java library. These are the functions you should usually be using.

There are also "@code{j}" variants ("@code{j}" is for "Java") of all the the logging functions which use SLF4J style formatting. These use "@{@}" as the placeholders, and the arguments are passed down to the SLF4J Java layer to be converted there. These variants are useful if you're working with actual Java objects in your Octave code, and you want Java to handle the type conversion. In the "@code{j}" variants, all the input arguments are converted to Java objects using Octave's default auto-conversion.

Some Octave objects may not convert to Java objects at all, so you'll get errors when trying to use the "@code{j}" variants with them.

@example
>> d = database;
>> logger.infoj('My database: @{@}', d)
No method 'info' with matching signature found for class 'org.slf4j.impl.Log4jLoggerAdapter'.
Error in logger.Logger/infoj (line 146)
        this.jLogger.info(msg, varargin@{:@});
Error in loggerCallImpl (line 69)
                logger.infoj(msg, args@{:@});
Error in logger.infoj (line 13)
loggerCallImpl('info', msg, varargin, 'j');
@end example

To avoid this, use the regular variants.

In both cases, the formatting and conversion is done lazily: if the logger is not enabled at the level you are logging the event, the function returns without doing the conversion. So you only pay the cost of the @code{sprintf()} or Java conversion and formatting if the logger is enabled.

@node Logger names
@subsection Logger names

The logging functions in @code{+logger} use the caller's class or function name as the logger name. (This is in line with the Java convention of using the fully-qualified class name as the logger name.) This is accomplished with a trick using @code{dbstack}, looking back up the call stack to see who invoked it.

You can use anything for a logger name; if no logger of that name exists, one is created automatically. Logger names are arranged in a hierarchy using dot-qualified prefixes, like package names in Java or Octave. For example, if you have the following loggers:

@itemize
@item @code{foo.Thing}
@item @code{foo.bar.Thing}
@item @code{foo.bar.OtherThing}
@item @code{foo.bar.baz.Whatever}
@end itemize

Then:

@itemize
@item All these loggers are children of the logger @code{foo}
@item @code{foo.bar.Thing} and @code{foo.bar.OtherThing} are children of @code{foo.bar}, which in turn is a child of @code{foo}.
@item @code{foo.bar.baz.Whatever} is a child of @code{foo.bar.baz}, which is a child of @code{foo.bar}, which is a child of @code{foo}.
@end itemize

@node The Logger object
@subsubsection The Logger object

You can also use the object-oriented @code{logger.Logger} API directly. This allows you to set custom logger names. It'll also be a bit faster, because it doesn't have to spend time extracting the caller name from the call stack. To use the Logger object directly, get a logger object by calling @code{logger.Logger.getLogger(name)} where @code{name} is a string holding the name of the logger you want to use. 

@example
logger = logger.Logger.getLogger('foo.bar.baz.MyThing');
logger.info('Something happened');
@end example

If you use @code{logger.Logger} in object-oriented Octave code, I recommend you do it like this, which looks like the SLFJ Java conventions.

@example
classdef CallingLoggerDirectlyExample

    properties (Constant, Access=private)
        log = logger.Logger.getLogger('foo.bar.baz.qux.MyLoggerID');
    end

    methods
        function hello(this)
            this.log.info('Hello, world!');
        end

        function doWork(this)
            label = 'thingy';
            x = 1 + 2;
            timestamp = datetime;
            this.log.debug('Calculation result: label=%s, x=%f at %s', label, x, timestamp);
         end
    end

end
@end example

Even though @code{log} is a @code{Constant} (static) property, I like to call it via @code{this} because it's more concise, and then you can copy and paste your code that makes logging calls between classes. Make the @code{log} property @code{private} so you can have @code{log} properties defined in your subclasses, too; they may want to use different IDs.


@node The dispstr API
@chapter The dispstr API

In addition to the SLF4J adapter layer, SLF4O provides a new API for generic value formatting and customizing the display of user-defined objects. This consists of a pair of functions, @code{dispstr} and @code{dispstrs}. They take values of any type and convert them to either a single string, or an array of strings corresponding to the input array's elements.

This is the equivalent of Java's @code{toString()} method, which is defined for almost everything and customized extensively. (Well, really it's equivalent to Java's @code{""+x} string concatenation operation, which really is defined for everything.)

@example
    str = dispstr(x)     % Returns char string
    strs = dispstrs(x)   % Returns cellstr array
@end example

The input @code{x} may be *any* type.

Normally when writing a library, I avoid defining any global functions, to avoid polluting the shared namespace. But @code{dispstr} and @code{dispstrs} *must* be global functions, because they are polymorphic over all input types, including those which are themselves unaware of @code{dispstr}.

This provides an extension point for defining custom string conversions for your own user-defined classes. You can override @code{dispstr} and @code{dispstrs} in your classes, and SLF4O will recognize it. I find this is useful for other string formatting, too.

For uniformity, if you define @code{dispstr} in a class, I recommend that you override @code{disp} to make use of it. And you'll typically want to make @code{dispstr} and @code{dispstrs} consistent.

@example
    function disp(this)
        disp(dispstr(this));
    end

    % Standard implementation of dispstr
    function out = dispstr(this)
        if isscalar(this)
            strs = dispstrs(this);
            out = strs@{1@};
        else
            out = sprintf('%s %s', size2str(size(this)), class(this));
        end
    end
@end example

As a convenience, there is a @code{logger.Displayable} mix-in class which takes care of this boilerplate for you. It provides standard implementations of @code{disp} and @code{dispstr} in terms of @code{dispstrs}. If you inherit from @code{logger.Displayable}, you only need to define @code{dispstrs}.

@node The dispstr interface
@section The dispstr interface

The @code{dispstr} function/method takes a single argument, which may be an array of any size, and returns a single one-line string.

The @code{dispstrs} function/method takes a single argument, which may be an array of any size, and returns a @code{cellstr} array of exactly the same size as the input. For @code{strs = dispstrs(x)}, the string in @code{strs@{i@}} corresponds to the input @code{x(i)}.

@node How dispstr and SLF4O interact
@subsection How dispstr and SLF4O interact

When you call the normal ("@code{m}") variants of the logging functions, @code{dispstr()} is applied to any inputs which are objects, so they're converted automatically and may be passed as parameters for the @code{%s} conversion. (In the normal Octave @code{sprintf}, most objects cannot be passed to @code{%s}; it results in an error.)

@example
    d = database;
    logger.info('Database: %s', d);
@end example

For most Octave-defined objects, this just results in a "@code{m-by-n <classname>}" output. (But at least it doesn't raise an error, which is especially problematic when your functions are receiving inputs of the wrong type.) It gets particularly useful when you define custom @code{dispstr} overrides so your objects have useful string representations.


@node Configuration
@chapter Configuration

All the actual logging goes through the Log4j back end; you can configure it as with any Log4j installation. See the Log4j 1.2 documentation (@url{http://logging.apache.org/log4j/1.2/} for details. (Note: you have to use the old 1.2 series doco, because that's what SLF4O currently ships with, due to a desire to maintain parity with SLF4J, which is constrained by the Log4j version that Matlab ships with.)

The @code{logger.Log4jConfigurator} class provides a convenient Octave-friendly interface for configuring Log4j to do basic stuff. It's enough for simple cases. But all the configuration state is passed on the the Log4j back end; none of it is stored in the Octave layer.


@node Implementation notes
@chapter Implementation notes

I chose Log4j as the back end because that's what SLF4M uses, and I wanted to be maximally compatible with SLF4M.
SLF4M chose Log4j as the back end because that's what ships with Matlab.

Aside from the @code{dispstr} formatting, everything is done purely in terms of the underlying SLF4J interface, so SLF4O is compatible with any other code or tools that use SLF4J or Log4j.


@node API Reference
@chapter API Reference

@node API by Category
@section API by Category
@subsection Logging
@table @asis
@item @ref{logger.Logger}
Main entry point through which logging happens

@item @ref{logger.Log4jConfigurator}
A configurator tool for Log4j

@item @ref{logger.debug}
Log a DEBUG level message from caller, with printf style formatting.

@item @ref{logger.debugj}
Log a DEBUG level message from caller, with SLF4J style formatting.

@item @ref{logger.error}
Log an ERROR level message from caller, with printf style formatting.

@item @ref{logger.errorj}
Log an ERROR level message from caller, with SLF4J style formatting.

@item @ref{logger.info}
Log an INFO level message from caller, with printf style formatting.

@item @ref{logger.infoj}
Log an INFO level message from caller, with SLF4J style formatting.

@item @ref{logger.trace}
Log a TRACE level message from caller, with printf style formatting.

@item @ref{logger.tracej}
Log a TRACE level message from caller, with SLF4J style formatting.

@item @ref{logger.warn}
Log a WARN level message from caller, with printf style formatting.

@item @ref{logger.warnj}
Log a WARN level message from caller, with SLF4J style formatting.

@item @ref{logger.initSLF4O}
Initialzie SLF4O

@item @ref{logger.initSLF4M}
SLF4M compatibility shim for initSLF4O

@item @ref{logger.version}
Gets version info for the SLF4O library.

@end table
@subsection Dispstr
@table @asis
@item @ref{dispstr}
This returns a one-line string representing the input value, in a format suitable for inclusion into multi-element output.

@item @ref{dispstrs}
Get display strings for array elements.

@item @ref{prettyprint}
Formatted output of array contents.

@item @ref{pp}
Command wrapper for prettyprint().

@item @ref{fprintfds}
A variant of fprintf() that supports dispstr functionality.

@item @ref{sprintfds}
A variant of sprintf() that supports dispstr functionality.

@item @ref{errords}
A variant of error() that supports dispstr functionality.

@item @ref{warningds}
A variant of warning() that supports dispstr functionality.

@item @ref{size2str}
Format a matrix size for display.

@end table
@subsection Uncategorized
@table @asis
@item @ref{mustBeA}
Validate that an input is of a particular data type.

@end table

@node API Alphabetically
@section API Alphabetically
@menu
* dispstr::	This returns a one-line string representing the input
		value, in a format suitable for inclusion into
		multi-element output.
* dispstrs::	Get display strings for array elements.
* errords::	A variant of error() that supports dispstr functionality.
* fprintfds::	A variant of fprintf() that supports dispstr functionality.
* logger.debug::	Log a DEBUG level message from caller, with printf
		style formatting.
* logger.debugj::	Log a DEBUG level message from caller, with SLF4J
		style formatting.
* logger.error::	Log an ERROR level message from caller, with printf
		style formatting.
* logger.errorj::	Log an ERROR level message from caller, with SLF4J
		style formatting.
* logger.info:: Log an INFO level message from caller, with printf style
		formatting.
* logger.infoj::	Log an INFO level message from caller, with SLF4J
		style formatting.
* logger.initSLF4M::	SLF4M compatibility shim for initSLF4O
* logger.initSLF4O::	Initialzie SLF4O
* logger.Log4jConfigurator::	A configurator tool for Log4j
* logger.Logger::	Main entry point through which logging happens
* logger.trace::	Log a TRACE level message from caller, with printf
		style formatting.
* logger.tracej::	Log a TRACE level message from caller, with SLF4J
		style formatting.
* logger.version::	Gets version info for the SLF4O library.
* logger.warn:: Log a WARN level message from caller, with printf style
		formatting.
* logger.warnj::	Log a WARN level message from caller, with SLF4J
		style formatting.
* mustBeA::	Validate that an input is of a particular data type.
* pp::	Command wrapper for prettyprint().
* prettyprint:: Formatted output of array contents.
* size2str::	Format a matrix size for display.
* sprintfds::	A variant of sprintf() that supports dispstr functionality.
* warningds::	A variant of warning() that supports dispstr functionality.
@end menu

@node dispstr
@subsection dispstr

@deftypefn {Function} {@var{out} =} dispstr (@var{x})
@deftypefnx {Function} {@var{out} =} dispstr (@var{x}, @var{options})

This returns a one-line string representing the input value, in a format
suitable for inclusion into multi-element output. The output describes the
entire input array in a single string (as opposed to dumping all its
elements.)

The intention is for user-defined classes to override this method, providing
customized display of their values.

The input x may be a value of any type. The main DISPSTR implementation has
support for Matlab built-ins and common types. Other user-defined objects are
displayed in a generic "m-by-n <class> array" format.

Options may be a struct or an n-by-2 cell array of name/value pairs (names in
column 1; values in column 2).

Returns a single string as char.

Options:
  QuoteStrings  - Put scalar strings in quotes.

Examples:
@example
  dispstr(magic(3))
@end example

See also:
DISPSTRS, SPRINTFDS

@end deftypefn


@node dispstrs
@subsection dispstrs

@deftypefn {Function} {@var{out} =} dispstrs (@var{x})
@deftypefnx {Function} {@var{out} =} dispstrs (@var{x}, @var{options})

Get display strings for array elements.

DISPSTRS returns a cellstr array containing display strings that represent the
values in the elements of x. These strings are concise, single-line strings
suitable for incorporation into multi-element output. If x is a cell, each
element cell's contents are displayed, instead of each cell.

Unlike DISPSTR, DISPSTRS returns output describing each element of the input
array individually.

This is used for constructing display output for functions like DISP.
User-defined objects are expected to override DISPSTRS to produce suitable,
readable output.

The output is human-consumable text. It does not have to be fully precise, and
does not have to be parseable back to the original input. Full type
information will not be inferrable from DISPSTRS output. The primary audience
for DISPSTRS output is Octave programmers and advanced users.

The intention is for user-defined classes to override this method, providing
customized display of their values.

The input x may be a value of any type. The main DISPSTRS implementation has
support for Octave built-ins and common types. Other user-defined objects are
displayed in a generic "m-by-n <class> array" format.

Returns a cellstr the same size as x.

Options:
  None are currently defined. This argument is reserved for future use.

Examples:
  dispstrs(magic(3))

See also: DISPSTR

@end deftypefn


@node errords
@subsection errords

@deftypefn {Function} errords (@var{fmt}, @var{varargin})
@deftypefnx {Function} errords (@var{errorId}, @var{fmt}, @var{varargin})

A variant of error() that supports dispstr functionality.

This is just like Octave's error(), except you can pass objects
directly to @code{%s} conversion specifiers, and they will be automatically
converted using dispstr.

@end deftypefn


@node fprintfds
@subsection fprintfds

@deftypefn {Function} fprintfds (@var{fmt}, @var{varargin})
@deftypefnx {Function} fprintfds (@var{fid}, @var{fmt}, @var{varargin})

A variant of fprintf() that supports dispstr functionality.

This is just like Octave's fprintf(), except you can pass objects
directly to @code{%s} conversion specifiers, and they will be automatically
converted using dispstr.

See the documentation for SPRINTFDS for details on how it works.

Examples:

@example
bday = Birthday(3, 14);
fprintfds('The value is: %s', bday)
@end example

See also:
SPRINTFDS

@end deftypefn


@node logger.debug
@subsection logger.debug
@deftypefn {Function} logger.debug (@var{msg}, @var{varargin})
@deftypefnx {Function} logger.debug (@var{exception}, @var{msg}, @var{varargin})

Log a DEBUG level message from caller, with printf style formatting.

This accepts a message with printf style formatting, using '%...' formatting
controls as placeholders.

Examples:

@example
logger.debug('Some message. value1=%s value2=%d', 'foo', 42);
@end example

@end deftypefn


@node logger.debugj
@subsection logger.debugj
@deftypefn {Function} logger.debugj (@var{msg}, @var{varargin})

Log a DEBUG level message from caller, with SLF4J style formatting.

This accepts a message with SLF4J style formatting, using '@{@}' as placeholders for
values to be interpolated into the message.

Examples:

@example
logger.debugj('Some message. value1=@{@} value2=@{@}', 'foo', 42);
@end example

@end deftypefn


@node logger.error
@subsection logger.error
@deftypefn {Function} logger.error (@var{msg}, @var{varargin})
@deftypefnx {Function} logger.error (@var{exception}, @var{msg}, @var{varargin})

Log an ERROR level message from caller, with printf style formatting.

This accepts a message with printf style formatting, using '%...' formatting
controls as placeholders.

Examples:

@example
logger.error('Some message. value1=%s value2=%d', 'foo', 42);
@end example

@end deftypefn


@node logger.errorj
@subsection logger.errorj
@deftypefn {Function} logger.errorj (@var{msg}, @var{varargin})

Log an ERROR level message from caller, with SLF4J style formatting.

This accepts a message with SLF4J style formatting, using '@{@}' as placeholders for
values to be interpolated into the message.

Examples:

@example
logger.errorj('Some message. value1=@{@} value2=@{@}', 'foo', 42);
@end example

@end deftypefn


@node logger.info
@subsection logger.info
@deftypefn {Function} logger.info (@var{msg}, @var{varargin})
@deftypefnx {Function} logger.info (@var{exception}, @var{msg}, @var{varargin})

Log an INFO level message from caller, with printf style formatting.

This accepts a message with printf style formatting, using '%...' formatting
controls as placeholders.

Examples:

@example
logger.info('Some message. value1=%s value2=%d', 'foo', 42);
@end example

@end deftypefn


@node logger.infoj
@subsection logger.infoj
@deftypefn {Function} logger.infoj (@var{msg}, @var{varargin})

Log an INFO level message from caller, with SLF4J style formatting.

This accepts a message with SLF4J style formatting, using '@{@}' as placeholders for
values to be interpolated into the message.

Examples:

@example
logger.infoj('Some message. value1=@{@} value2=@{@}', 'foo', 42);
@end example

@end deftypefn


@node logger.initSLF4M
@subsection logger.initSLF4M
@deftypefn {Function} logger.initSLF4M ()

SLF4M compatibility shim for initSLF4O

This is an alias for initSLF4O. Calling it just results in initSLF4O()
being called.

This function is provided as a compatibility shim so that code which is
expecting SLF4M will still work with SLF4O.

@end deftypefn


@node logger.initSLF4O
@subsection logger.initSLF4O
@deftypefn {Function} logger.initSLF4O ()

Initialzie SLF4O

This function must be called once before you use SLF4O.

@end deftypefn


@node logger.Log4jConfigurator
@subsection logger.Log4jConfigurator

@deftp {Class} logger.Log4jConfigurator

A configurator tool for Log4j

This class configures the logging setup for Octave/SLF4O logging. It
configures the log4j library that SLF4O logging sits on top of.

This class is provided as a convenience. You can also configure SLF4O logging
by directly configuring log4j using its normal Java interface.

SLF4O does not automatically configure log4j. You must either call a
configureXxx method on this class or configure log4j directly yourself to get
logging to work. Otherwise, you may get warnings like this at the console:

  log4j:WARN No appenders could be found for logger (unknown).
  log4j:WARN Please initialize the log4j system properly.

If that happens, it means you need to call
logger.Log4jConfigurator.configureBasicConsoleLogging.

This also provides a log4j configuration GUI that you can launch with
`logger.Log4jConfigurator.showGui`.

Examples:

@example
logger.Log4jConfigurator.configureBasicConsoleLogging

logger.Log4jConfigurator.setLevels(@{'root','DEBUG'@});

logger.Log4jConfigurator.setLevels(@{
    'root'    'INFO'
    'net.apjanke.logger.swing'  'DEBUG'
    @});

logger.Log4jConfigurator.prettyPrintLogConfiguration

% Display fully-qualified class/category names in the log output:
logger.Log4jConfigurator.setRootAppenderPattern(...
   ['%d@{HH:mm:ss.SSS@} %p %c - %m' sprintf('\n')]);

% Bring up the configuration GUI
logger.Log4jConfigurator.showGui
@end example

@end deftp


@node logger.Log4jConfigurator.configureBasicConsoleLogging
@subsubsection logger.Log4jConfigurator.configureBasicConsoleLogging

@deftypefn {Static Method} logger.Log4jConfigurator.configureBasicConsoleLogging ()

Configures log4j to do basic logging to the console

This sets up a basic log4j configuration, with log output going to the
console, and the root logger set to the INFO level.

This method can safely be called multiple times. If there's already an
appender on the root logger (indicating logging has already been
configured), it silently does nothing.

@end deftypefn

@node logger.Log4jConfigurator.setRootAppenderPattern
@subsubsection logger.Log4jConfigurator.setRootAppenderPattern

@deftypefn {Static Method} logger.Log4jConfigurator.setRootAppenderPattern (@var{pattern})

Sets the pattern on the root appender

This is just a convenience method. Assumes there is a single
appender on the root logger.

@end deftypefn

@node logger.Log4jConfigurator.getLog4jLevel
@subsubsection logger.Log4jConfigurator.getLog4jLevel

@deftypefn {Static Method} logger.Log4jConfigurator.getLog4jLevel (@var{levelName})

Gets the log4j Level Java enum value for a named level.

@var{levelName} is a charvec containing the name of the log level, such as
@code{'INFO'} or @code{'DEBUG'}. It may also be one of the special names
@code{'OFF'} or @code{'ALL'}.

Returns a Java org.apache.log4j.Level enum object.

@end deftypefn

@node logger.Log4jConfigurator.setLevels
@subsubsection logger.Log4jConfigurator.setLevels

@deftypefn {Static Method} logger.Log4jConfigurator.setLevels (@var{levels})

Set the logging levels for multiple loggers

logger.Log4jConfigurator.setLevels(levels)

This is a convenience method for setting the logging levels for multiple
loggers.

The levels input is an n-by-2 cellstr with logger names in column 1 and
level names in column 2.

Examples:

@example
logger.Log4jConfigurator.setLevels(@{'root','DEBUG'@});

logger.Log4jConfigurator.setLevels(@{
    'root'    'INFO'
    'net.apjanke.logger.swing'  'DEBUG'
    @});
@end example

@end deftypefn

@node logger.Log4jConfigurator.prettyPrintLogConfiguration
@subsubsection logger.Log4jConfigurator.prettyPrintLogConfiguration

@deftypefn {Static Method} logger.Log4jConfigurator.prettyPrintLogConfiguration ()
@deftypefnx {Static Method} logger.Log4jConfigurator.prettyPrintLogConfiguration (@var{verbose})

Displays the current log configuration to the console.

@var{verbose} is a logical flag indicating whether verbose mode should be used.
Defaults to false.

@end deftypefn

@node logger.Log4jConfigurator.showGui
@subsubsection logger.Log4jConfigurator.showGui

@deftypefn {Static Method} logger.Log4jConfigurator.showGui ()

Display the Log4j configuration GUI provided by SLF4O.

BROKEN!!!

This tool is currently broken, and will probably crash Octave if you call it.

@end deftypefn

@node logger.Logger
@subsection logger.Logger
@deftp {Class} logger.Logger

Main entry point through which logging happens

The Logger class provides method calls for performing logging, and the ability
to look up loggers by name. This is the main entry point through which all
SLF4O logging happens.

Usually you don't need to interact with this class directly, but can just call
one of the error(), warn(), info(), debug(), or trace() functions in the logger
namespace. Those will log messages using the calling class's name as the name
of the logger. Also, don't call the constructor for this class. Use the static
getLogger() method instead.

Use this class directly if you want to customize the names of the loggers to
which logging is directed.

Each of the logging methods - error(), warn(), info(), debug(), and
trace() - takes a sprintf()-style signature, with a format string as
the first argument, and substitution values as the remaining
arguments.
@example
   logger.info(format, varargin)
@end example
You can also insert an MException object at the beginning of the
argument list to have its message and stack trace included in the log
message.
@example
   logger.warn(exception, format, varargin)
@end example

See also:
logger.error
logger.warn
logger.info
logger.debug
logger.trace

Examples:

@example
log = logger.Logger.getLogger('foo.bar.FooBar');
log.info('Hello, world! Running on Octave %s', version);
@end example

@example
try
    some_operation_that_could_go_wrong();
catch err
    log.warn(err, 'Caught exception during processing')
end
@end example

@end deftp


@node logger.Logger.getLogger
@subsubsection logger.Logger.getLogger

@deftypefn {Static Method} {@var{obj} =} logger.Logger.getLogger (@var{identifier})

Gets the named Logger.

Returns a logger.Logger object.

@end deftypefn

@node logger.Logger.Logger
@subsubsection logger.Logger.Logger

@deftypefn {Constructor} {@var{obj} =} logger.Logger (@var{jLogger})

Build a new logger object around an SLF4J Logger object.

Generally, you shouldn't call this. Use logger.Logger.getLogger() instead.

@end deftypefn

@node logger.Logger.error
@subsubsection logger.Logger.error

@deftypefn {Method} error (@var{obj}, @var{msg}, @var{varargin})
@deftypefnx {Method} error (@var{obj}, @var{exception}, @var{msg}, @var{varargin})

Log a message at the ERROR level.

@end deftypefn

@node logger.Logger.warn
@subsubsection logger.Logger.warn

@deftypefn {Method} warn (@var{obj}, @var{msg}, @var{varargin})
@deftypefnx {Method} warn (@var{obj}, @var{exception}, @var{msg}, @var{varargin})

Log a message at the WARN level.

@end deftypefn

@node logger.Logger.info
@subsubsection logger.Logger.info

@deftypefn {Method} info (@var{obj}, @var{msg}, @var{varargin})
@deftypefnx {Method} info (@var{obj}, @var{exception}, @var{msg}, @var{varargin})

Log a message at the INFO level.

@end deftypefn

@node logger.Logger.debug
@subsubsection logger.Logger.debug

@deftypefn {Method} debug (@var{obj}, @var{msg}, @var{varargin})
@deftypefnx {Method} debug (@var{obj}, @var{exception}, @var{msg}, @var{varargin})

Log a message at the DEBUG level.

@end deftypefn

@node logger.Logger.trace
@subsubsection logger.Logger.trace

@deftypefn {Method} trace (@var{obj}, @var{msg}, @var{varargin})
@deftypefnx {Method} trace (@var{obj}, @var{exception}, @var{msg}, @var{varargin})

Log a message at the TRACE level.

@end deftypefn

@node logger.Logger.errorj
@subsubsection logger.Logger.errorj

@deftypefn {Method} errorj (@var{obj}, @var{msg}, @var{varargin})

Log a message at the ERROR level, using SLF4J formatting.

@end deftypefn

@node logger.Logger.warnj
@subsubsection logger.Logger.warnj

@deftypefn {Method} warnj (@var{obj}, @var{msg}, @var{varargin})

Log a message at the WARN level, using SLF4J formatting.

@end deftypefn

@node logger.Logger.infoj
@subsubsection logger.Logger.infoj

@deftypefn {Method} infoj (@var{obj}, @var{msg}, @var{varargin})

Log a message at the INFO level, using SLF4J formatting.

@end deftypefn

@node logger.Logger.debugj
@subsubsection logger.Logger.debugj

@deftypefn {Method} debugj (@var{obj}, @var{msg}, @var{varargin})

Log a message at the DEBUG level, using SLF4J formatting.

@end deftypefn

@node logger.Logger.tracej
@subsubsection logger.Logger.tracej

@deftypefn {Method} tracej (@var{obj}, @var{msg}, @var{varargin})

Log a message at the TRACE level, using SLF4J formatting.

@end deftypefn

@node logger.Logger.isErrorEnabled
@subsubsection logger.Logger.isErrorEnabled

@deftypefn {Method} {@var{out} =} isErrorEnabled (@var{obj})

True if ERROR level logging is enabled for this logger.

@end deftypefn

@node logger.Logger.isWarnEnabled
@subsubsection logger.Logger.isWarnEnabled

@deftypefn {Method} {@var{out} =} isWarnEnabled (@var{obj})

True if WARN level logging is enabled for this logger.

@end deftypefn

@node logger.Logger.isInfoEnabled
@subsubsection logger.Logger.isInfoEnabled

@deftypefn {Method} {@var{out} =} isInfoEnabled (@var{obj})

True if INFO level logging is enabled for this logger.

@end deftypefn

@node logger.Logger.isDebugEnabled
@subsubsection logger.Logger.isDebugEnabled

@deftypefn {Method} {@var{out} =} isDebugEnabled (@var{obj})

True if DEBUG level logging is enabled for this logger.

@end deftypefn

@node logger.Logger.isTraceEnabled
@subsubsection logger.Logger.isTraceEnabled

@deftypefn {Method} {@var{out} =} isTraceEnabled (@var{obj})

True if TRACE level logging is enabled for this logger.

@end deftypefn

@node logger.Logger.listEnabledLevels
@subsubsection logger.Logger.listEnabledLevels

@deftypefn {Method} {@var{out} =} listEnabledLevels (@var{obj})

List the levels that are enabled for this logger.

The enabled levels are listed by name.

Returns a cellstr vector or empty.

@end deftypefn

@node logger.trace
@subsection logger.trace
@deftypefn {Function} logger.trace (@var{msg}, @var{varargin})
@deftypefnx {Function} logger.trace (@var{exception}, @var{msg}, @var{varargin})

Log a TRACE level message from caller, with printf style formatting.

This accepts a message with printf style formatting, using '%...' formatting
controls as placeholders.

Examples:

@example
logger.trace('Some message. value1=%s value2=%d', 'foo', 42);
@end example

@end deftypefn


@node logger.tracej
@subsection logger.tracej
@deftypefn {Function} logger.tracej (@var{msg}, @var{varargin})

Log a TRACE level message from caller, with SLF4J style formatting.

This accepts a message with SLF4J style formatting, using '@{@}' as placeholders for
values to be interpolated into the message.

Examples:

@example
logger.tracej('Some message. value1=@{@} value2=@{@}', 'foo', 42);
@end example

@end deftypefn


@node logger.version
@subsection logger.version
@deftypefn {Function} logger.version ()
@deftypefnx {Function} {@var{out} =} logger.version ()

Gets version info for the SLF4O library.

If return value is not captured, displays version info for SLF4O and related
libraries to the console.

If return value is captured, returns the version of the SLF4O library as
a char vector.

@end deftypefn


@node logger.warn
@subsection logger.warn
@deftypefn {Function} logger.warn (@var{msg}, @var{varargin})
@deftypefnx {Function} logger.warn (@var{exception}, @var{msg}, @var{varargin})

Log a WARN level message from caller, with printf style formatting.

This accepts a message with printf style formatting, using '%...' formatting
controls as placeholders.

Examples:

@example
logger.warn('Some message. value1=%s value2=%d', 'foo', 42);
@end example

@end deftypefn


@node logger.warnj
@subsection logger.warnj
@deftypefn {Function} logger.warnj (@var{msg}, @var{varargin})

Log a WARN level message from caller, with SLF4J style formatting.

This accepts a message with SLF4J style formatting, using '@{@}' as placeholders for
values to be interpolated into the message.

Examples:

@example
logger.warnj('Some message. value1=@{@} value2=@{@}', 'foo', 42);
@end example

@end deftypefn


@node mustBeA
@subsection mustBeA

@deftypefn {Function} mustBeA (@var{value}, @var{type})

Validate that an input is of a particular data type.

Validates that the input Value is of the specified Type or a
subtype. If Value is not of Type, an error is raised. If Value is
of Type, does nothing and returns.

Value is the value to validates the type of. It may be anything. If
you call it using a variable (as opposed to a longer expression),
the variable name is included in any error messages.

Type (char) is the name of the type that Value must be. A type
name may be one of:
  * A class, such as 'double', 'cell', or 'containers.Map'
  * One of the special SLF4O pseudotypes:
      cellstr
      numeric
      object
      any

Note: The cellstr pseudotype is nontrivial to check for, as it
must call iscellstr() and check all cell contents.

Examples:

@example
function foo(x, someStrings)
  mustBeA(x, 'double');
  mustBeA(someStrings, 'cellstr');
endfunction
@end example

@end deftypefn


@node pp
@subsection pp

@deftypefn {Function} pp (@var{varargin})

Command wrapper for prettyprint().

PP is a command-oriented wrapper for prettyprint, intended for interactive
use. Code should not call this.

Right now, it just calls PRETTYPRINT on its input, but the intention is to
extend it to take variable names as chars in addition to the normal
prettyprint input, so you can say 'pp foo' instead of 'pp(foo)'. This is
purely a convenience to save users from typing in parentheses.

@end deftypefn


@node prettyprint
@subsection prettyprint

@deftypefn {Function} {@var{out} =} prettyprint (@var{x})

Formatted output of array contents.

Displays a formatted, human-readable representation of the contents of a
value. This is a detailed, multi-line output that typically displays all the
individual values in an array, or drills down one or more levels into complex
objects. In many cases, this is just like doing a DISP, but it respects the
DISPSTR and DISPSTRS methods defined on user-defined objects inside complex
types, where DISP does not.

This output is for human consumption and its format may change over time. The
format may also be dependent on settings in the Octave session, such as
`format` and the user's locale.

The default PRETTYPRINT implementation has support for Octave built-in types,
structs, cells, and tables, and, unlike the default disp() behavior for them,
respects DISPSTRS defined for values inside structs, cells, and tables.

The input x may be a value of any type.

If the output is not captured, displays its results to the console. If the
output is captured, returns its results as char.

The intention is for user-defined classes to override this method, providing
customized display of their values.

@end deftypefn


@node size2str
@subsection size2str

@deftypefn {Function} {@var{out} =} size2str (@var{sz})

Format a matrix size for display.

Sz is an array of dimension sizes, in the format returned by SIZE.

Returns a charvec.

@end deftypefn


@node sprintfds
@subsection sprintfds

@deftypefn {Function} sprintfds (@var{fmt}, @var{varargin})

A variant of sprintf() that supports dispstr functionality.

This is just like Octave's sprintf(), except you can pass objects
directly to @code{%s} conversion specifiers, and they will be automatically
converted using dispstr.

For inputs that are objects, dispstr() is implicitly called on them, so you
can pass them directly to '%s' conversion specifiers in your format
string.

Examples:

@example
bday = Birthday(3, 14);
str = sprintfds('The value is: %s', bday)
@end example

See also:
FPRINTFDS

@end deftypefn


@node warningds
@subsection warningds

@deftypefn {Function} warningds (@var{fmt}, @var{varargin})
@deftypefnx {Function} warningds (@var{warningId}, @var{fmt}, @var{varargin})

A variant of warning() that supports dispstr functionality.

This is just like Octave's warning(), except you can pass objects
directly to @code{%s} conversion specifiers, and they will be automatically
converted using dispstr.

@end deftypefn





@node Copying
@chapter Copying


@section Package Copyright

SLF4O for Octave is covered by the GNU GPLv3.

All the code in the package is GNU GPLv3.

@section Manual Copyright

@insertcopying

@bye
